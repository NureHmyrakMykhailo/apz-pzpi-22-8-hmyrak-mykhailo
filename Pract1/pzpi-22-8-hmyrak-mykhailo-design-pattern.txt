Міністерство освіти та науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії




Практична робота №1
з дисципліни: «Архітектура програмного забезпечення»












Виконав:                                                                     
ст. гр. ПЗПІ-22-8                                                             
Гмирак Михайло Дмитрович                                        

Перевірив:
ст. викладач кафедри ПІ 
Сокорчук І.П.



Харків 2025
1 ПАТЕРНИ ПРОЄКТУВАННЯ
     1.1 Історія змін 
     
     Зміни в документі нотуються до таблиці 1.1
     
Таблиця 1.1 – Історія змін 
№
Дата
Версія звіту
Опис змін та виправлень
1
13.04.2025
0.1
Створено розділ «Історія змін»
2
13.04.2025
0.1
Створено розділ «Завдання до практичної роботи»
3
13.04.2025
0.1
Створено розділ «Опис виконаної роботи»
4
13.04.2025
0.1
Створено розділ «Висновки»
5
13.04.2025
0.1
Додано додаток А з посиланням на відеоролик
6
13.04.2025
0.1
Додано додаток Б зі слайдами презентації
7
13.04.2025
0.1
Додано додаток В з програмним кодом





















     1.2 Завдання до практичної роботи
     
     
     Завдання полягає в ознайомленні з патерном проєктування Command та дослідженні його застосування в об’єктно-орієнтованому програмуванні. Необхідно зрозуміти, як цей патерн дозволяє інкапсулювати запити як об’єкти, забезпечуючи можливість передавати, зберігати, ставити в чергу або скасовувати операції. У межах роботи слід реалізувати власний приклад застосування патерну Command, наприклад, для управління пристроями або обробки запитів. Також необхідно пояснити переваги та недоліки підходу, а також розглянути можливі альтернативи.
     
     
     1.3 Опис виконаної роботи
     
     
     У рамках цієї практичної роботи було розглянуто патерн проєктування Command, який належить до поведінкових патернів і широко застосовується в об’єктно-орієнтованому програмуванні. Суть цього патерну полягає в інкапсуляції запиту у вигляді окремого об'єкта. Такий підхід дозволяє розділити відповідальність між об’єктом, який ініціює дію, та об’єктом, який її виконує. Це забезпечує більшу гнучкість і контроль над операціями, оскільки запити можна зберігати, ставити в чергу, передавати іншим об'єктам або навіть скасовувати.
     Усі елементи патерну Command взаємодіють у чітко визначеній структурі. Клієнт створює конкретні об’єкти команд і встановлює зв’язок між ними та ініціатором. Команда визначається через інтерфейс, який містить метод виконання, зазвичай названий execute. Конкретна команда реалізує цей інтерфейс і містить посилання на об’єкт, який виконує справжню роботу. Цей об’єкт називається приймачем. Ініціатор зберігає команду та викликає її виконання, коли це необхідно. Такий поділ дозволяє змінювати логіку виконання команд, не змінюючи код самого ініціатора чи приймача.
     Для демонстрації роботи патерну було реалізовано просту модель системи керування освітленням. Основний клас Light виконує роль приймача та містить методи для вмикання і вимикання світла. Створено дві команди: одна для ввімкнення світла, інша — для вимкнення. Обидві реалізують інтерфейс команди та передають виклики методів об’єкта Light. Роль ініціатора виконує клас RemoteControl, який зберігає команду та викликає її, імітуючи натискання кнопки. Така реалізація дозволяє легко змінювати поведінку пульта керування, просто підставляючи іншу команду, без жодних змін у його внутрішній логіці.
     Реалізований приклад показує, як можна досягти гнучкості та масштабованості в програмному забезпеченні, уникаючи прямого зв’язку між відправником і виконавцем дії. Завдяки інкапсуляції команд стало можливим зберігати дії для подальшого виконання або реалізовувати механізм скасування (undo), що є дуже корисним для побудови складних інтерфейсів користувача або серверних систем з обробкою черги запитів.
     Command-патерн дозволяє створювати розширювані системи, де нові команди додаються без змін у вже написаному коді. Проте, окрім переваг, він має і певні недоліки. Зокрема, при великій кількості команд кількість класів зростає, що може ускладнити підтримку проєкту. Також для простих задач використання такого патерну може бути надмірним. Тим не менш, у складних системах його використання виправдане завдяки гнучкості, яку він забезпечує.
     У ході дослідження були розглянуті й альтернативи патерну Command. Наприклад, у сучасних мовах програмування часто використовуються лямбда-вирази, що дозволяють передавати поведінку без створення окремих класів. Також подібні задачі іноді вирішуються за допомогою патерну Strategy, який дозволяє замінювати алгоритми на льоту. Проте Strategy не підтримує можливості скасування або відкладеного виконання, що відрізняє його від Command. У певних випадках також можуть використовуватись делегати або комбінування патерну Command з іншими патернами, наприклад Composite, що дозволяє об’єднувати декілька команд в одну.
     Отже, у межах цієї роботи було не лише реалізовано приклад використання патерну Command, а й проаналізовано його роль у проєктуванні програмного забезпечення. Було продемонстровано, як цей підхід дозволяє створювати чисту, модульну та гнучку архітектуру, яка легко адаптується до змін і нових вимог.
     
     
     1.4 Висновки 
     
     
     Патерн Command є потужним засобом інкапсуляції запитів у вигляді об'єктів. Він забезпечує високий рівень гнучкості та розширюваності, дозволяючи змінювати поведінку програми без зміни існуючого коду. Command особливо корисний у складних системах, де потрібно підтримувати історію дій, реалізовувати Undo/Redo або виконання дій за розкладом. Однак важливо враховувати складність структури та збільшення кількості класів при його використанні.
     
     













Додаток А
Хронологічний опис та посилання


     Відеозапис доповіді на YouTube: https://youtu.be/gTJuvc1rRw0

     Хронологічний опис доповіді:
     00:00  Вступна частина
Ознайомлення з темою доповіді, коротке пояснення суті патерну Command та структури презентації.
     00:29  Що таке патерн проєктування Command
Визначення патерну Command як поведінкового шаблону, що дозволяє обгорнути запит у об’єкт для зручної обробки.
     00:57  Основні компоненти патерну
Перерахування ключових учасників патерну: інтерфейс, конкретна команда, Invoker та Receiver.
     01:25  Архітектура патерну проєктування Command
Демонстрація, як елементи патерну взаємодіють між собою у реальній системі за принципом клієнт–команда–виконавець.
     02:00  Приклади використання патерну
Огляд ситуацій, де застосовується патерн: GUI, Undo/Redo, сервери, ігрові рушії.
     02:25  Переваги використання
Висвітлення сильних сторін патерну: гнучкість, масштабованість, підтримка історії команд.
     02:54  Недоліки патерну
Коротко про недоліки: надлишкова кількість класів, складність у малих проєктах.
     03:26  Реалізація патерну на прикладі
Практичний приклад на C#: керування світлом через пульт, команди в стилі патерну Command.
     04:15  Альтернативи патерну
Варіанти спрощення або доповнення: делегати, lambda-вирази, комбінації з іншими патернами.
     04:37  Використані джерела
Перелік джерел, які використовувались для створення презентації, включаючи книги та технічні сайти.
     04:50  Завершення
Підсумок ключових тез, подяка за увагу та запрошення до запитань.


















Додаток Б
Слайди презентації доповіді



Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Що таке патерн проєктування Command

Рисунок Б.3 – Основні компоненти патерну


Рисунок Б.4 – Архітектура патерну Command



Рисунок Б.5 – Приклади використання


Рисунок Б.6 – Переваги використання


Рисунок Б.7 – Недоліки патерну


Рисунок Б.8 – Реалізація патерну на прикладі



Рисунок Б.9 – Альтернативи та розширення


Рисунок Б.10 – Викорастенні джерела



Рисунок Б.11 – Фінальний слайд













Додаток В
Приклад реалізації патерну на мові C#


1   // 1. Інтерфейс команди
2   public interface ICommand
3   {
4       void Execute();
5       void Undo();
6   }
7
8   // 2. Приймач
9   public class Light
10  {
11      public void On() => Console.WriteLine("Світло увімкнено.");
12      public void Off() => Console.WriteLine("Світло вимкнено.");
13  }
14
15  // 3. Конкретні команди
16  public class LightOnCommand : ICommand
17  {
18      private Light _light;
19
20      public LightOnCommand(Light light)
21      {
22          _light = light;
23      }
24
25      public void Execute() => _light.On();
26      public void Undo() => _light.Off();
27  }
28
29  public class LightOffCommand : ICommand
30  {
31      private Light _light;
32
33      public LightOffCommand(Light light)
34      {
35          _light = light;
36      }
37
38      public void Execute() => _light.Off();
39      public void Undo() => _light.On();
40  }
41
42  // 4. Ініціатор
43  public class RemoteControl
44  {
45      private ICommand _command;
46
47      public void SetCommand(ICommand command)
48      {
49          _command = command;
50      }
51
52      public void PressButton()
53      {
54          _command.Execute();
55      }
56
57      public void PressUndo()
58      {
59          _command.Undo();
60      }
61  }
62
63  // 5. Клієнтський код
64  class Program
65  {
66      static void Main()
67      {
68          Light livingRoomLight = new Light();
69          ICommand lightOn = new LightOnCommand(livingRoomLight);
70          ICommand lightOff = new LightOffCommand(livingRoomLight);
71
72          RemoteControl remote = new RemoteControl();
73
74          // Вмикаємо світло
75          remote.SetCommand(lightOn);
76          remote.PressButton();
77
78          // Вимикаємо світло
79          remote.SetCommand(lightOff);
80          remote.PressButton();
81
82          // Undo
83          remote.PressUndo();
84      }
85  }
2


